---
author: Alex
date: 2021-01-13
layout: post
title: 运行时依赖、编译时依赖在前端领域的概念与实现
tags:
  - 技术
  - 架构
---

## why

纯前端的小伙伴对运行时和编译时依赖的概念比较模糊，所以这里想分享一下其中的原理，与感兴趣的前端小伙一起探讨，同时让我们前端小队成员更深入地了解我们的低代码平台的前端架构。

## what

什么是运行时依赖，什么是编译时依赖？纯前端的小伙伴应该对此概念比较陌生。其实这些都是成熟后端语言的构建术语，例如 Java。

如果我用前端的话术来解释，可能就很容易理解了：

1. 运行时依赖：我们的业务代码在运行到某一行时，通过全局对象 `window` 查找被依赖的模块，例如 `window.react`。这个时候就是运行时依赖 `react`。
2. 编译时依赖：在工程构建工具（通常是 webpack）编译代码时，将模块之间的依赖编译进代码，前提是没有配置外置模块（external）。例如 `import React from 'react'`。这个时候就是编译时依赖 `react`。

通过 webpack 的 externals 将三方依赖分离，这个相信很多小伙伴都是有所认识的，但是其背后的概念可能小伙伴们并不太熟悉。所以这里想谈的就是这个背后的概念与具体落地方案。

### 运行时依赖

通常，我们会通过 CDN 地址获取已经构建好的库，并且我们编写的业务库需要在别人的库加载完成后再加载。

例如我们通过 CDN 加载 react，我们的业务代码库紧跟其后：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.1/umd/react.production.min.js"></script>
<!-- 业务代码 -->
<script src="https://biz-code.js"></script>
```

这个时候我们的业务代码就是在运行时依赖 `react`。这个也是前端常见的性能优化手段之一，将代码开发时所依赖的包，按照某种规则分割成多个包。

但是这篇文章并不是将性能优化，而是想要通过这个`运行时依赖`这个概念，讲述 1. 如何多人异步开发应用；2. 打造更稳定的、高容错的、可持续交付的应用工程。

作为对比，会先讲述一下什么是编译时依赖。

### 编译时依赖

其实就是写在前端 npm 工程中的 `package.json` 中的 `dependencies` 下的所有项。

例如最简单的 package.json 描述：

```json
{
  "name": "package-name",
  "dependencies": {
    "react": "^17.0.1",
    "react-dom": "^17.0.1"
  },
  "scripts": {
    "start": "node start.js"
  }
}
```

一般的前端工程脚手架，例如 `create-react-app`，是基于 webpack 处理所有的模块的。熟悉 webpack 的朋友应该都知道`入口 entry`的概念。一般情况下，webpack 会将分析模块的依赖，就是 `import` 了什么，然后将 `import` 的模块也编译进 `bundler.js` 中。

所以按照上面的 json 描述，webpack 将会把 `react` 和 `react-dom` 与我们的业务代码一起编译（compile）。也就是说，我们在编译时依赖了 `react` 和 `react-dom`。

这种方式就称为`编译时依赖`（除非写 webpack 配置时用 `externals`）。

---

## 前端工程的现状

就目前而言，大部分的 web 软件项目都是简单业务（_只有业务量足够大，才会有更多的技术与非技术问题需要解决，这也是大公司与小公司在技术上的主要区别，这是题外话_）。

当项目规模很小的时候，其实区别是不大的。开源社区有很多成熟的、开箱即用的脚手架（例如 create-react-app、umi），开发小规模项目都挺好用挺快的。要做到这么简单易用，最好的途径就是脚手架直接依赖对应的开发库，这样就导致使用脚手架工具就等于`编译时依赖`所有的三方库。

因为编译时依赖是最简单的依赖管理和构建方式。

### 问题

一旦项目规模上了一定的程度，业务模块越来越多，越来越纠缠不清、三方依赖包的数量越来越多，只有编译时依赖的问题就爆发了：工程的依赖逐渐会陷入混乱的状态，构建速度越来越慢，调试将越来越难。不彻底解决，团队将难以前进。

我们也遇到了同样的问题了，所以我们思考如何解决这些问题。

### 解决思路

其实在工程中，绝大部分的三方依赖是不会被改动的。所以构建工具 webpacck 已经帮我们找到了解决的办法了，就是将三方库改为 `运行时依赖`。也就是通过 webpack config 中的 externals 将三方库做成静态库，从工程开发中分离出来。

例如 react react-dom：

```json
/// webpack config
/// 这里不详细解释这个原理
{
  "externals": {
    "react": "React",
    "react-dom": "ReactDOM",
    ...
  }
}
```

## 做正确的判断

![img](../../assets/images/依赖分层图例.jpg)

有了上述的初步认知，我们可以对一个符合中大型工程的脚手架，做出一些分层判断：

### 核心库

我们可以最稳定的、最底层的依赖归类核心库，例如 react, react-dom

### 工具库

我们可以将基于核心库（也可以不必）扩展而来的三方库归类工具库，例如 material-ui, react-router

### 业务库

顾名思义，这一类就是我们针对业务开发的业务代码。同时还可以针对不同的业务场景进一步对业务库进行切割，按照业务功能来继续划分。

## 业务架构

对于业务库的进一步划分，才是整个业务系统有真正意义上的架构。

对于架构的看法，这里我引用《The art of scalability》的观点：架构要对系统的可扩展性、稳定性负全责。什么是可扩展性？就是随着业务的增减，可以通过动态增减人员的组织需求，并且即使人员有变动，系统依然是稳定的，可用的。_所以可扩展性并不非一个技术的问题，而是技术+人事的问题。_

那么有什么办法可以做到？

### 设置分离点

什么是分离点？就是将模块与模块之间切底隔绝。想象一下，我们是如何与三方服务对接的？例如接入微信支付、支付宝支付？我们是通过文档与其做技术对接。三方服务将提供 SDK，我们将集成于我们的业务系统之中。

所以，分离点就是将模块分拆成独立服务，并且对外提供 SDK 和对接文档。TODO

